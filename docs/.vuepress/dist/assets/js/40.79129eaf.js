(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{456:function(e,t,n){"use strict";n.r(t);var a=n(2),s=Object(a.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"前言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),t("p",[e._v("前段时间接手了一个项目，一天发现进入一个模块页面时每次都很卡顿排查发现一个下拉框的数据源后端一次性返回了2万条数据，之前做这个功能的前端估计也没考虑到后续数据会这么大直接渲染到页面。刚好最近刷到过相关的面试题，这里对相关方案做个总结。")]),e._v(" "),t("h2",{attrs:{id:"前置工作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前置工作"}},[e._v("#")]),e._v(" 前置工作")]),e._v(" "),t("p",[e._v("先还原问题场景和相关代码")]),e._v(" "),t("h3",{attrs:{id:"后端搭建mock数据"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#后端搭建mock数据"}},[e._v("#")]),e._v(" 后端搭建mock数据")]),e._v(" "),t("p",[e._v("新建server.js文件，循环生成10万条数据，node启动服务")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// server.js\n\nimport  http  from 'http';\n\nhttp.createServer(function (req, res) {\n  // 开启Cors\n  res.writeHead(200, {\n    //设置*允许跨域\n    'Access-Control-Allow-Origin': '*',\n    \"Access-Control-Allow-Methods\": '*',\n  })\n  let list = []\n  let value = 0\n\n  // 生成1万条数据的list\n  for (let i = 0; i < 100000; i++) {\n    value++\n    list.push({\n      label: `选项${value}`,\n      value: value,\n    })\n  }\n  res.end(JSON.stringify(list));\n}).listen('8000')\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" // 启动服务\n node server\n")])])]),t("h3",{attrs:{id:"前端vue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前端vue"}},[e._v("#")]),e._v(" 前端vue")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<script setup>\n  import {ref,onMounted, nextTick} from "vue";\n\n  const list =ref([])\n  // ajax请求获取后端返回所有数据\n  const getList = () => {\n    return new Promise((resolve, reject) => {\n      var ajax = new XMLHttpRequest();\n      ajax.open(\'get\', \'http://127.0.0.1:8000\');\n      ajax.send();\n      ajax.onreadystatechange = function () {\n        if (ajax.readyState == 4 && ajax.status == 200) {\n          resolve(JSON.parse(ajax.responseText))\n        }\n      }\n    })\n  }\n  onMounted( ()=>{\n    // 渲染全部数据\n    renderAll()\n\n    // setTimeout渲染\n    renderSetTimeOut()\n\n    // requestAnimationFrame渲染\n    renderRequestAnimationFrame()\n\n    // 懒加载\n    // renderLazy()\n\n    // 虚拟列表渲染\n    renderVoidList()\n  })\n<\/script>\n\n<template>\n  <div id="container">\n    <el-select\n        clearable\n    >\n      <el-option v-for="op in list" :key="op.value" :label="op.label" :value="op.value"></el-option>\n    </el-select>\n  </div>\n</template>\n')])])]),t("h2",{attrs:{id:"接收数据后直接渲染"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#接收数据后直接渲染"}},[e._v("#")]),e._v(" 接收数据后直接渲染")]),e._v(" "),t("p",[e._v("先看看卡顿的问题根源，一次性渲染10万个dom节点消耗时间导致卡顿，由于10万条数据测试卡顿太久，这里我用1万条数据测试渲染时间约为20s")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const renderAll = async () => { \n console.time()\n list.value = await getList()\n await nextTick()\n console.timeEnd()\n}\n")])])]),t("h2",{attrs:{id:"settimeout渲染"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#settimeout渲染"}},[e._v("#")]),e._v(" setTimeout渲染")]),e._v(" "),t("p",[e._v("定时器虽然解决了首次渲染卡死的问题，但是由于是定时任务一直在不断的添加dom节点进行重排，所以打开下拉框后滑动依然会很卡且很消耗资源")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const renderSetTimeOut = async () => {\n  const listAll = await getList()\n  const total = listAll.length\n  const page = 0\n  const pageSize = 300\n  const totalPage = Math.ceil(total / pageSize)\n\n  const render = (page) => {\n    if (page >= totalPage) return\n    setTimeout(() => {\n      // 每隔一段时间截取下页的数据渲染\n      const array = listAll.slice(page * pageSize, (page + 1) * pageSize)\n      list.value = list.value.concat(array)\n      render(page + 1)\n    }, 0)\n  }\n  render(page)\n}\n")])])]),t("h2",{attrs:{id:"requestanimationframe"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#requestanimationframe"}},[e._v("#")]),e._v(" requestAnimationFrame")]),e._v(" "),t("p",[e._v("requestAnimationFrame跟setTimeout 的原理一样都是定时循环，只不过在动画帧上渲染的性能和效果更好。这里最终的结果跟setTimeout都存在一样的问题")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const renderRequestAnimationFrame = async () => {\n  const listAll = await getList()\n  const total = listAll.length\n  const page = 0\n  const pageSize = 300\n  const totalPage = Math.ceil(total / pageSize)\n\n  const render = (page) => {\n    if (page >= totalPage) return\n    requestAnimationFrame(() => {\n      const array = listAll.slice(page * pageSize, (page + 1) * pageSize)\n      list.value = list.value.concat(array)\n      render(page+1)\n    })\n  }\n  render(page)\n}\n")])])]),t("h2",{attrs:{id:"懒加载"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#懒加载"}},[e._v("#")]),e._v(" 懒加载")]),e._v(" "),t("p",[e._v("对返回的所有数据进行分页处理，默认渲染第一页的数据，每次"),t("strong",[e._v("触发触底加载下一页数据")])]),e._v(" "),t("h2",{attrs:{id:"自定义指令触发触底"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自定义指令触发触底"}},[e._v("#")]),e._v(" 自定义指令触发触底")]),e._v(" "),t("p",[e._v("找到下拉弹窗的dom节点并监听滚动，触底触发绑定的函数")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 自定义指定触底\nconst loadMoreDirective = {\n  mounted(el, binding) {\n    // 找到下拉滚动节点\n    let select_dom = document.querySelector('.el-select-dropdown .el-select-dropdown__wrap');\n    select_dom.addEventListener('scroll', function () {\n      // 确定滚动区域是否滚动到底\n      let height = this.scrollHeight - this.scrollTop <= this.clientHeight;\n      if (height) {\n        binding.value(binding.arg)\n      }\n    })\n  },\n}\n\nconst vLoadMore = loadMoreDirective\n")])])]),t("h2",{attrs:{id:"触底加载更多"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#触底加载更多"}},[e._v("#")]),e._v(" 触底加载更多")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const loadMore = () => {\n  const total = listAll.value.length\n  const pageSize = 300\n  const totalPage = Math.ceil(total / pageSize)\n  if (page.value >= totalPage) return\n  page.value++\n  const array = listAll.value.slice(page.value * pageSize, (page.value + 1) * pageSize)\n  list.value = list.value.concat(array)\n}\n\nconst page = ref(0)\nconst listAll = ref([])\n// 加载首页数据和所有数据\nconst renderLazy = async () => {\n  listAll.value = await getList()\n  const pageSize = 300\n  const array = listAll.value.slice(page.value * pageSize, (page.value + 1) * pageSize)\n  list.value = list.value.concat(array)\n}\n")])])]),t("h2",{attrs:{id:"实现效果图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现效果图"}},[e._v("#")]),e._v(" 实现效果图")]),e._v(" "),t("p",[e._v("每次触底加载下一页300条数据")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afeebdf5891441ec90fce49d3eb9252b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image",alt:""}})]),e._v(" "),t("h2",{attrs:{id:"虚拟列表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#虚拟列表"}},[e._v("#")]),e._v(" 虚拟列表")]),e._v(" "),t("h3",{attrs:{id:"虚拟列表的理解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#虚拟列表的理解"}},[e._v("#")]),e._v(" 虚拟列表的理解")]),e._v(" "),t("p",[t("strong",[e._v("渲染可视区域")]),e._v("内的数据，"),t("strong",[e._v("不渲染非可视区域")]),e._v("内数据，同时列表中监听滚动条滚动事件，")]),e._v(" "),t("p",[e._v("动态截取所有数据中需要渲染的数据到可视区域内")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef2d10b20f5445b393392e1cbb662bcd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image",alt:""}})]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<template>\n  <el-select\n      clearable\n      v-scroll=\"loadScroll\"\n      popper-class=\"custom-popper\"\n  >\n    <el-option v-for=\"op in visibleList\" :key=\"op.value\" :label=\"op.label\" :value=\"op.value\"></el-option>\n  </el-select>\n</template>\n\n<script setup>\nimport {ref, onMounted, computed} from \"vue\";\n\n// 节流\nconst throttle =(func, delay) => {\n  let timer = null;\n\n  return function() {\n    const context = this;\n    const args = arguments;\n\n    if (!timer) {\n      timer = setTimeout(function() {\n        func.apply(context, args);\n        timer = null;\n      }, delay);\n    }\n  }\n}\n// 滚动自定义指令\nconst scrollDirective = {\n  mounted(el, binding) {\n    // 找到下拉滚动dom节点\n    let select_dom = document.querySelector('.custom-popper .el-select-dropdown__wrap');\n    select_dom.addEventListener('scroll', function () {\n      binding.value(this.scrollTop)\n    })\n  },\n}\nconst vScroll = scrollDirective\n\n// 下拉选项高度\nconst itemHeight = ref(34)\n// 可视区域高度即下拉框滚动区域高度\nconst screenHeight = ref(274)\n// 开始索引\nconst startIndex = ref(0)\n// 结束索引，可视区域 / 下拉项高度 * 2 = 可视区域内展示多少项 * 2\n// 274 / 34 * 2 = 16 多加载一屏数据防止滑动过快出现白屏\nconst endIndex = ref(16)\n// 所有下拉选项数据\nconst listAll = ref([])\n// 可视区域计算截取需要显示的数据\nconst visibleList = computed(() => {\n  return listAll.value.slice(startIndex.value, endIndex.value);\n})\n\nconst getList = () => {\n  return new Promise((resolve, reject) => {\n    var ajax = new XMLHttpRequest();\n    ajax.open('get', 'http://127.0.0.1:8000');\n    ajax.send();\n    ajax.onreadystatechange = function () {\n      if (ajax.readyState == 4 && ajax.status == 200) {\n        //步骤五 如果能够进到这个判断 说明 数据 完美的回来了,并且请求的页面是存在的\n        resolve(JSON.parse(ajax.responseText))\n      }\n    }\n  })\n}\n\n// 滚动节流提高性能\nconst loadScroll = throttle((scrollHeight) => {\n  // 已滚动的高度 / 单个选项高度  = 已滚动选项即当前开始索引\n  startIndex.value =  Math.floor(scrollHeight / itemHeight.value)\n  // 可视区域展示8项，多加载一屏防止白屏\n  endIndex.value = startIndex.value + 16;\n  // 获取滚动区域dom节点\n  let dropdownListDom = document.querySelector('.custom-popper .el-select-dropdown__list')\n  // 计算上方已滚动下拉项高度模拟设置滚动条的位置： 开始索引*下拉选项高度 = 上方已滚动高度\n  // 因element默认样式设置了important，所以需要覆盖原样式\n  dropdownListDom.style.setProperty('padding-top', startIndex.value*itemHeight.value + 'px', 'important');\n},50)\n\nconst renderVoidList = async () => {\n  listAll.value = await getList()\n  // 获取所有数据后，设置ul节点的高度撑开容器，模拟所有数据都存在时滚动条的位置\n  let dropdownListDom = document.querySelector('.custom-popper .el-select-dropdown__list')\n  dropdownListDom.style.height = listAll.value.length  * itemHeight.value +`px`;\n}\n\nonMounted(() => {\n  renderVoidList()\n})\n<\/script>\n")])])]),t("h2",{attrs:{id:"实现效果图-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现效果图-2"}},[e._v("#")]),e._v(" 实现效果图")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af729dec4b4a4551bde72091a537ac1a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image",alt:""}})])])}),[],!1,null,null,null);t.default=s.exports}}]);